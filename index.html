<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>BungeeZoo</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            background: #000; 
            display: flex; 
            justify-content: center; 
            align-items: center; 
            min-height: 100vh;
            overflow: hidden;
            touch-action: none;
        }
        canvas { 
            max-width: 100%; 
            max-height: 100vh;
            cursor: pointer;
        }
    </style>
</head>
<body>
<canvas id="game"></canvas>
<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const WIDTH = 1280, HEIGHT = 720;
canvas.width = WIDTH;
canvas.height = HEIGHT;

// Colors
const SKY_COLOR = '#87CEEB';
const GRASS_COLOR = '#228B22';
const ROPE_COLOR = '#8B4513';

// Load images
const imageNames = ['bear.png', 'bull.png', 'cow.png', 'fishbowl.png', 'milk-free.png', 'monkey.png', 'monkey2.png', 'rabbit.png'];
const images = {};
let loadedCount = 0;

imageNames.forEach(name => {
    const img = new Image();
    img.onload = () => {
        loadedCount++;
        if (loadedCount === imageNames.length) init();
    };
    img.onerror = () => {
        // Create colored placeholder
        const c = document.createElement('canvas');
        c.width = 70; c.height = 70;
        const cx = c.getContext('2d');
        cx.fillStyle = `hsl(${Math.random()*360}, 70%, 60%)`;
        cx.beginPath();
        cx.arc(35, 35, 30, 0, Math.PI * 2);
        cx.fill();
        cx.fillStyle = '#000';
        cx.font = '12px Arial';
        cx.textAlign = 'center';
        cx.fillText(name.split('.')[0], 35, 40);
        images[name] = c;
        loadedCount++;
        if (loadedCount === imageNames.length) init();
    };
    img.src = 'images/' + name;
    images[name] = img;
});

// Physics
function calculateBungeePhysics(y, vel, gravity, k, damping, restLength) {
    let force = gravity;
    const displacement = y - restLength;
    if (displacement > 0) {
        force += -k * displacement;
    }
    const newVel = (vel + force) * damping;
    const newY = y + newVel;
    return [newY, newVel];
}

// Character class
class Character {
    constructor(imageName, xPos) {
        this.imageName = imageName;
        this.xPos = xPos;
        this.screenHeight = HEIGHT;
        this.randomizeRope();
        this.respawn();
    }

    randomizeRope() {
        const minLen = this.screenHeight * 0.3;
        const maxLen = this.screenHeight * 1.05;
        this.restLength = minLen + Math.random() * (maxLen - minLen);
        this.kStiffness = 0.03 + Math.random() * 0.02;
    }

    respawn() {
        this.isSplatted = false;
        this.yFloat = -100 - Math.random() * 500;
        this.vel = 0;
        this.wasFalling = true;
        this.splatTimer = 0;
        this.safetyTimer = 0;
        this.lifeLimit = 300 + Math.random() * 200;
        this.randomizeRope();
        this.angle = 0;
    }

    update() {
        const floorY = this.screenHeight - 50;

        if (this.isSplatted) {
            this.splatTimer++;
            if (this.splatTimer > 60) this.respawn();
            return;
        }

        this.safetyTimer++;
        if (this.safetyTimer > this.lifeLimit) {
            this.respawn();
            return;
        }

        const GRAVITY = 0.5;
        const DAMPING = 0.99;
        [this.yFloat, this.vel] = calculateBungeePhysics(
            this.yFloat, this.vel, GRAVITY, this.kStiffness, DAMPING, this.restLength
        );

        if (this.yFloat >= floorY) {
            this.isSplatted = true;
            this.vel = 0;
            this.yFloat = floorY;
            return;
        }

        // Rotation/swing
        const swingIntensity = 15 + Math.abs(this.vel) * 2;
        this.angle = Math.sin(Date.now() * 0.005 + this.xPos) * swingIntensity * Math.PI / 180;
    }

    draw(ctx) {
        const floorY = this.screenHeight - 50;

        if (!this.isSplatted) {
            // Draw rope
            ctx.strokeStyle = ROPE_COLOR;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(this.xPos, 0);
            
            if (this.yFloat < this.restLength) {
                // Wavy rope when not stretched
                const midX = this.xPos + (Math.random() - 0.5) * 10;
                const midY = this.yFloat / 2;
                ctx.bezierCurveTo(midX - 10, midY, midX + 10, midY + 20, this.xPos, this.yFloat - 35);
            } else {
                ctx.lineTo(this.xPos, this.yFloat - 35);
            }
            ctx.stroke();
        }

        // Draw character
        const img = images[this.imageName];
        const size = 70;
        
        ctx.save();
        if (this.isSplatted) {
            // Draw splat
            ctx.fillStyle = '#B00000';
            ctx.beginPath();
            ctx.ellipse(this.xPos, floorY + 10, 45, 20, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#DC0000';
            ctx.beginPath();
            ctx.ellipse(this.xPos, floorY + 5, 35, 22, 0, 0, Math.PI * 2);
            ctx.fill();
        } else {
            ctx.translate(this.xPos, this.yFloat);
            ctx.rotate(this.angle);
            if (img.complete || img.tagName === 'CANVAS') {
                ctx.drawImage(img, -size/2, -size/2, size, size);
            } else {
                ctx.fillStyle = '#FFF';
                ctx.beginPath();
                ctx.arc(0, 0, size/2, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        ctx.restore();
    }
}

// Game state
let characters = [];

function init() {
    const numChars = imageNames.length;
    const padding = 40;
    const step = (WIDTH - padding * 2) / (numChars - 1);

    for (let i = 0; i < numChars; i++) {
        const xPos = padding + i * step;
        characters.push(new Character(imageNames[i], xPos));
    }

    // Input handlers
    canvas.addEventListener('click', resetAll);
    canvas.addEventListener('touchstart', (e) => { e.preventDefault(); resetAll(); });
    document.addEventListener('keydown', (e) => {
        if (e.key === 'r' || e.key === 'R') resetAll();
    });

    requestAnimationFrame(gameLoop);
}

function resetAll() {
    characters.forEach(c => c.respawn());
}

function gameLoop() {
    // Update
    characters.forEach(c => c.update());

    // Draw
    ctx.fillStyle = SKY_COLOR;
    ctx.fillRect(0, 0, WIDTH, HEIGHT);

    // Floor
    ctx.fillStyle = GRASS_COLOR;
    ctx.fillRect(0, HEIGHT - 50, WIDTH, 50);

    // Characters
    characters.forEach(c => c.draw(ctx));

    // UI
    ctx.fillStyle = '#FFF';
    ctx.font = '24px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('Tap to Reset', WIDTH / 2, 30);

    requestAnimationFrame(gameLoop);
}

// Start loading
if (loadedCount === imageNames.length) init();
</script>
</body>
</html>
